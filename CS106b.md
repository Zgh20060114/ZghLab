##### 三五法则
- 三法则（C++98）：如果类里面的这三个函数：拷贝构造函数，拷贝赋值重载运算符，析构函数，中的一个被自定义了，那么必须全部实现这三个。因为这三个默认都是浅拷贝，要自定义就要改成深拷贝。
- 五法（C++11引入了移动语义）：再把移动构造函数，移动赋值重载运算符都实现了.
- 三五法则：只要是资源管理类（类的析构函数里有没有释放/摧毁某些资源），动这五个函数中的一个，就要全部实现。
- 零法则：用智能指针,让标准库帮你管理资源，就不用写析构/移动/拷贝
##### RAII（resource acquire is initialization)
- 把资源的申请放到构造函数中，把资源的释放放到析构函数中
- 平时常用的 `std::vector,std::string, std::unique_ptr` 等都是RAII
<!-- ##### 不要挑剔，能用就行，不要完美主义 -->

#### B讲的是ADT（抽象数据结构）和ADT的实现（具体数据结构）,还没讲到具体数据结构的使用（容器，容器适配器）

- abstraction 抽象
- recursive 递归 
- diagnostic 诊断
- reasoning 推理
- would not able to 原本不能
- survey 调查，概览
- prior 先进的，优先的
- placement 分配
- literacy 素养，能力
- enrill in 注册
- simultaneous 同步的
- implementation 执行,实现
- buckets 桶，水桶，档次, 区间
- getting used to 逐渐适应
- syntax 语法
- whirlwind 旋风
- interactive 互动的，交互式的
- caveat 警告，说明
- beware 谨防，当心
- phrase 短语, 表达

- vectors + grids
- stacks + queues
- sets + maps

- ![第一次见可以这样写测试](assets/2025-11-17-19-36-26.png)

- complement 补充
- sequence 序列
- prototype 原型
- strand 片段
- case 大小写
- (in)sensitive (不)敏感的
- guarantee 保证
- underlying 根本的，底层的
- transcend 超越
- shrink 收缩
- eliminate 消除
- 注意$ \color{red}值传递 $和$ \color{red}引用传递$
- excatly 精确地，完全地
- establish 建立
- pattern 规律，模式
- pitfall 陷阱
- idiom 习惯
- ADT (abstract data type) 抽象数据类型
- 在循环之前计算一次size
- std::queue是容器适配器，std::deque才是容器
- downside 缺点
- traversal 遍历
- side-effect of queue & stack 副作用
  - no random access
  - you can only iterate over all elements in the structure by removing previous elements first
  - no easy way to search 

- shuffle 打乱
- duplicate 重复，复制
- 容器适配器是以序列式容器为基础实现的ADT的实现，序列式容器是通用的储存方式，ADT和序列式容器、关联式容器没啥关系
- 大数据不适合递归，适合迭代，尾递归可以被编译器优化成迭代
- permutation 排列，置换
- potential 潜在的，可能的
- 手动分配的是在heap上; 声明的变量是在stack上,有作用域

- 完全二叉树：除最后一层节点都是满的，且最后一层的节点都在左侧
- 堆在逻辑上是一个完全二叉树，但是物理储存上可以用数组实现, 可以用来实现优先队列（最大堆，最小堆）
  - 父节点的优先级大于子节点
- 排序
  - 插入排序
  - 选择排序
  - 归并排序：先分割再合并

- x->var = (*x).var
- 链表虽然动态大小，插入删除快速；但是内存占用大，内粗不连续缓存不友好
- head存的是栈首元素的地址
- back存的是队列尾元素的地址
- 有序关联容器set/map的底层是以平衡二叉搜索树（一般是红黑树）来储存元素的；无序关联容器底层是hash表
- 二叉搜索树的左小右大是有延续性的（叶子节点也根节点的子节点）
- 平衡树的定义：左右子树高度差有限制
- hash table 哈希表，可以提供o(1)时间复杂度的增删查找，平衡二叉搜索树提供的是o(logn)的增删查找
- 哈希表：一种“压缩映射+解决冲突”的查表法,用数组储存值，用哈希函数用键计算出数组索引,空间换时间
- 键-(预哈希)-哈希值-(压缩)-数组索引
- adjacent 相邻的= neighbor
- vertex 顶点= node

- reachable:可达
- connected: 连通（任意两个节点之间都是可达的）
- complete: 完全（任意两个节点之间都存在直接相连的边）
- 连通图一定是完全图
- BFS(层序遍历)：queue
- DFS：递归(系统栈)/stack
- heap 堆，是一种有逻辑的数组
- 优先队列是用数组+堆实现的一种容器，和队列的关系只有：使用了队列一头出一头进的概念而已。所以priority_queue的底层其实是vector.
- std::list 列表，本质是双向链表（doubly linked list）
