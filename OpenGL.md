#### 进度
- 学了glad加载函数，glfw管理窗口，vbo，vao,ebo,着色器，


- 现代opengl是核心模式,废弃了立即渲染模式
- opengl就是一个巨大的状态机,各种状态变量规定了opengl接下来应该如何绘图渲染,此时的状态被称为opengl的上下文
  - 假设当我们想告诉OpenGL去画线段而不是三角形的时候，我们通过改变一些上下文变量来改变OpenGL状态，从而告诉OpenGL如何去绘图。一旦我们改变了OpenGL的状态为绘制线段，下一个绘制命令就会画出线段而不是三角形。
- opengl的对象(object),是各种状态的集合,隐藏在后台(内存)中,不能直接访问,需要用他的唯一ID来访问,所以直接创建objectId来创建对象
- compatibility 兼容性
- 由于glad.h里有是否已引入opengl头文件断言,所以写到上面,头文件引入顺序
- hint 暗示,提示
- clang-format off/on 
- major 主要的
- minor 次要的
- 引用是一种被隐藏的指针变量,指向原引用变量的地址,但是编译器会隐藏引用变量的地址
- proc 函数
- 帧缓冲里有:
  - 颜色缓冲
  - 深度缓冲
  - 模板缓冲 stencil 镂空模板
- 顶点缓冲对象vbo: 是储存在gpu显存里的数据
- 顶点数组对象vao :如何解析vbo里的数据
- 索引缓冲对象iao
- 图形渲染管线主要分为两个部分:
  - 将3D坐标转换成2D坐标
  - 将2D坐标转换成实际的有颜色的像素
- 渲染管线的不同阶段都有专门的gpu核心,运行专门的着色器程序(shader)
- 写shader的语言叫做glsl(opengl shading language)
- 指示将顶点数据渲染成什么形状的指令,叫做图元(`primitive`)
- 顶点(3D坐标和属性如颜色)
- ![渲染管线](assets_OpenGL/2026-01-07-20-32-13.png)
  - 顶点着色器:传入顶点,将3D坐标转化成另一种3D坐标;对属性做一些处理
    - 开发者通过opengl的api在gpu创建内存来储存顶点数据,告诉gpu,顶点数据的内存布局,顶点数据如何对应顶点着色器的输入变量
  - 通过vbo管理这个内存(显存),
- 几何着色器(可选):可以产生新的顶点,形成新的或其他的图元
- 图元装配:将顶点着色器/几何着色器输出的顶点按照图元指令装配成图元
- 光栅化:将图元(3D坐标)投影为屏幕上的像素(2D坐标),生成供后续片段着色器使用的片段,片段会在进入片段着色器之前进行裁剪,裁剪掉超出视图之外的像素,提高执行效率
- 片段是渲染出一个像素所需要的所有数据
- 片段着色器:输出计算后的片段,计算一个像素的最终颜色等属性,这也是所有opengl高级效果产生的地方.片段着色器通常包含3D场景数据(光照,阴影,光的颜色等等),用来计算一个像素的最终颜色.
- alpha(透明度)测试和混合操作:对片段着色器输出的片段进行alpha测试和混合操作:检验像素的深度值,决定时候应该丢弃;检验alpha值,进行混合blending
- opengl只处理标准化设备坐标系的坐标([-1,1]),超出的不显示
- strip 线
- sizeof 是cpp的内置运算符
- std::array 的&arr[0]和arr.data()是arr的首元素地址
- gl_Position是glsl为顶点着色器保留的内置输出变量,所以不需要声明:专门用于顶点着色器输出裁剪空间坐标(齐次坐标)
- 把fn+caps大写锁定改了,右win
- win+shift+上下左右 调整大小
- std::string 加R"()" 分行字符串
- .c_str() 返回c风格字符串数组指针
- 现代cpp中,0就是0,空指针是nullptr,NULL是过时的
#### git操作
- git fetch origin main 拉取最新的origin main 但是不合并
- git reset --hard origin/main 强制用origin/main覆盖当前版本


- std::vector不能cout,但是vec.data()可以(数组的首元素的地址)
- 片段着色器的作用是计算像素的最终颜色输出
- speficial 指定
- GL_FLOAT是枚举类型,GLfloat是变量类型
- m+xx 标记,可以用'xx,来跳转,用:delmarks xx删除标记,:delmarks!删除全部
- ibo索引缓冲对象/ebo元素缓冲对象:记录opengl要绘制的顶点索引
- opengl只支持三角形图元
- integer 整数
- static_cast<int*>(0)可以,但是static_cast<int*>(1)就不可以,因为0可以是空指针nullptr也可以是int,应该用reinterpret_cast<int *>(3),适用于跟内存,指针有关的转换
- 引用不是指针,指针不能赋值给引用, 正常变量才能赋值给引用
- int &a = b;对a的任何操作本质上都是对b的操作,对a取地址就是对b取地址
- explicit 只能用于构造函数或转换函数

- 纹理texture
- wrap 包裹，包围
- 纹理环绕方式
- 纹理过滤：邻近过滤，线性过滤
- 多级渐变纹理mipmap,并过滤
- mipmap只适用于纹理缩小的情况,纹理放大直接用纹理过滤就行
- c++本来就是c的超集，完全可以混合编译，cmake甚至优先兼容c
